# 商城小程序项目问题记录

## 前端API请求无法访问后端问题

### 问题描述
在前端应用(3000端口)中尝试访问后端API(8080端口)的管理员登录接口时，收到404错误：
```json
{"status": "fail", "message": "请求的资源不存在"}
```

### 问题原因
1. 前端使用了错误的端口号(3000)来访问后端服务(8080)
2. Vite代理配置中的rewrite规则导致API路径被错误处理：
```javascript
rewrite: (path) => path.replace(/^\/api/, '')
```
这导致发送到'/api/admin/login'的请求被转发到后端的'/admin/login'，而不是预期的'/api/admin/login'

### 解决方案
保留后端API在8080端口运行，修改前端Vite配置中的代理设置，移除rewrite规则：
```javascript
proxy: {
  '/api': {
    target: env.API_URL || 'http://localhost:8080',
    changeOrigin: true,
    // 移除rewrite以确保路径能正确传递到后端
    // rewrite: (path) => path.replace(/^\/api/, ''),
  },
}
```

## JWT令牌生成失败问题

### 问题描述
修复API代理配置后，用户成功连接到后端API，但在登录时收到以下错误：
```json
{
  "status": "error",
  "message": "令牌生成失败",
  "error": {
    "statusCode": 500,
    "status": "error"
  },
  "stack": "Error: 令牌生成失败\n    at generateToken (/Users/zhuanghaixin/WebstormProjects/cursor_code/商城小程序/mall-server/src/utils/jwtToken.js:22:15)\n    at /Users/zhuanghaixin/WebstormProjects/cursor_code/商城小程序/mall-server/src/controllers/adminController.js:175:19\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)",
  "errorCode": ""
}
```

### 问题原因
通过检查jwtToken.js文件和环境变量配置，发现登录失败是因为缺少JWT相关的环境变量配置：
- 虽然在.env文件中存在JWT配置，但在.env.development中缺少这些配置
- JWT令牌生成需要JWT_SECRET（密钥）和JWT_EXPIRES_IN（过期时间）参数

### 解决方案
在.env.development文件中添加JWT配置：
```
# JWT配置
JWT_SECRET=dev_secret_key_for_jwt_token_2023
JWT_EXPIRES_IN=7d
```

重启开发服务器后，管理员登录功能正常工作，能够成功生成JWT令牌并登录。

## 管理员账户配置问题

### 问题描述
需要为系统设置默认的管理员账户，以便初始化后可以登录管理后台。

### 解决方案
通过环境变量配置默认管理员账号，在.env.development文件中添加：
```
# 默认管理员配置
ADMIN_USERNAME=dev_admin
ADMIN_PASSWORD=dev_pass123
ADMIN_REAL_NAME=开发环境管理员
ADMIN_EMAIL=dev@example.com
```

在生产环境(.env.production)中使用更安全的密码：
```
# 默认管理员配置
ADMIN_USERNAME=admin
ADMIN_PASSWORD=Secure@Pr0d#Pass!23
ADMIN_REAL_NAME=系统管理员
ADMIN_EMAIL=admin@yourcompany.com
```

并修改管理员创建函数(adminController.js)以使用环境变量：
```javascript
await Admin.create({
    username: process.env.ADMIN_USERNAME || 'superadmin',
    password: process.env.ADMIN_PASSWORD || 'superpass123!',
    realName: process.env.ADMIN_REAL_NAME || '超级管理员',
    email: process.env.ADMIN_EMAIL || 'admin@example.com',
    role: 'admin',
    status: 'active'
});
```

## JWT在Node.js Express应用中的核心流程

### 什么是JWT
JSON Web Token (JWT) 是一种开放标准 (RFC 7519)，用于在各方之间安全地传输信息。JWT可以被签名（使用密钥）以确保其完整性和真实性。在Web应用中，JWT通常用于无状态的用户身份验证和信息交换。

### JWT的结构
JWT由三部分组成，以点（.）分隔：
1. **Header（头部）**：包含令牌类型和使用的签名算法
2. **Payload（负载）**：包含声明（用户信息和元数据）
3. **Signature（签名）**：用于验证消息的完整性

例如：`xxxxx.yyyyy.zzzzz`

### 在Express应用中实现JWT的核心流程

#### 1. 安装必要的包
```bash
npm install jsonwebtoken bcryptjs express
```

#### 2. 令牌生成流程
当用户登录成功后，服务器生成JWT令牌：

```javascript
// jwtToken.js
const jwt = require('jsonwebtoken');

/**
 * 生成JWT令牌
 * @param {Object} payload - 要包含在令牌中的数据
 * @param {string} secret - 用于签名的密钥
 * @param {string|number} expiresIn - 令牌过期时间
 * @returns {string} JWT令牌
 */
const generateToken = (payload, secret = process.env.JWT_SECRET, expiresIn = process.env.JWT_EXPIRES_IN) => {
  try {
    return jwt.sign(payload, secret, { expiresIn });
  } catch (error) {
    throw new Error('令牌生成失败');
  }
};

module.exports = { generateToken };
```

在登录控制器中使用：
```javascript
// authController.js
const { generateToken } = require('../utils/jwtToken');

exports.login = async (req, res) => {
  try {
    const { username, password } = req.body;
    
    // 1. 查找用户
    const user = await User.findOne({ where: { username } });
    
    // 2. 验证密码
    if (!user || !(await user.comparePassword(password))) {
      return res.status(401).json({
        status: 'fail',
        message: '用户名或密码错误'
      });
    }
    
    // 3. 生成JWT令牌
    const token = generateToken({
      id: user.id,
      username: user.username,
      role: user.role
    });
    
    // 4. 返回令牌和用户信息
    res.status(200).json({
      status: 'success',
      message: '登录成功',
      data: { user, token }
    });
  } catch (error) {
    res.status(500).json({
      status: 'error',
      message: error.message
    });
  }
};
```

#### 3. 验证中间件实现
创建一个中间件来验证请求中的JWT令牌：

```javascript
// authMiddleware.js
const { verifyToken } = require('../utils/jwtToken');

exports.protect = (req, res, next) => {
  try {
    // 1. 从请求头获取令牌
    const authHeader = req.headers.authorization;
    let token;
    
    if (authHeader && authHeader.startsWith('Bearer ')) {
      token = authHeader.split(' ')[1];
    }
    
    // 2. 检查令牌是否存在
    if (!token) {
      return res.status(401).json({
        status: 'fail',
        message: '您未登录，请登录后访问'
      });
    }
    
    // 3. 验证令牌
    const decoded = verifyToken(token);
    
    // 4. 将用户信息附加到请求对象
    req.user = decoded;
    
    // 5. 继续下一个中间件
    next();
  } catch (error) {
    res.status(401).json({
      status: 'fail',
      message: error.message
    });
  }
};

// 权限控制中间件
exports.restrictTo = (...roles) => {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({
        status: 'fail',
        message: '您没有权限执行此操作'
      });
    }
    next();
  };
};
```

#### 4. 应用到路由
在Express路由中应用JWT中间件：

```javascript
// routes.js
const express = require('express');
const authController = require('../controllers/authController');
const { protect, restrictTo } = require('../middlewares/authMiddleware');

const router = express.Router();

// 公开路由
router.post('/login', authController.login);
router.post('/register', authController.register);

// 需要身份认证的路由
router.use(protect); // 应用JWT验证中间件

// 获取用户个人资料
router.get('/profile', userController.getProfile);

// 需要特定角色的路由
router.delete('/users/:id', restrictTo('admin'), userController.deleteUser);

module.exports = router;
```

### JWT认证流程图
#### 核心流程​​
​用户登录​​ → 服务端生成 JWT → 返回给客户端。 

客户端存储 JWT​​（如 localStorage 或 Cookie）。

​后续请求携带 JWT​​ → 服务端验证 JWT → 授权访问。
```
┌──────────┐                                                    ┌──────────┐
│          │                                                    │          │
│  客户端  │                                                    │  服务器  │
│          │                                                    │          │
└──────────┘                                                    └──────────┘
      │                                                               │
      │  1. 发送登录请求 (用户名/密码)                                │
      │ ──────────────────────────────────────────────────────────>  │
      │                                                               │
      │                                                               │ 2. 验证凭据
      │                                                               │
      │  3. 返回JWT令牌                                               │
      │ <──────────────────────────────────────────────────────────  │
      │                                                               │
      │  4. 存储JWT令牌 (localStorage/Cookie)                         │
      │                                                               │
      │  5. 携带JWT令牌发送API请求                                    │
      │    Authorization: Bearer {token}                              │
      │ ──────────────────────────────────────────────────────────>  │
      │                                                               │
      │                                                               │ 6. 验证JWT令牌
      │                                                               │
      │                                                               │ 7. 提取用户信息
      │                                                               │
      │  8. 返回受保护的资源                                          │
      │ <──────────────────────────────────────────────────────────  │
      │                                                               │
```

### JWT的优缺点

#### 优点：
1. **无状态**：服务器不需要存储会话信息，减轻了服务器负担
2. **跨域**：可以轻松实现跨域认证
3. **可扩展性**：易于在分布式系统中实现认证
4. **移动端友好**：适用于移动应用API认证

#### 缺点：
1. **令牌大小**：JWT可能比传统的会话ID更大
2. **无法撤销**：签发后无法在到期前撤销（除非实现黑名单）
3. **敏感数据**：不应在JWT的负载中存储敏感信息
4. **复杂性**：实现和管理可能比传统会话复杂

### 最佳实践
1. **适当的过期时间**：设置合理的令牌过期时间（通常几小时到几天）
2. **使用HTTPS**：始终通过HTTPS传输JWT
3. **刷新令牌**：实现刷新令牌机制，以便长期保持用户登录状态
4. **密钥管理**：使用强健的密钥，并定期更换
5. **负载大小**：保持JWT负载小，只包含必要信息
6. **错误处理**：实现完善的JWT错误处理机制
7. **权限控制**：结合JWT实现细粒度的权限控制

### 实际应用中的注意事项
1. **令牌存储**：在浏览器中通常存储在localStorage或HttpOnly Cookie中（后者更安全）
2. **并发处理**：多个请求同时使用相同的JWT时可能出现并发问题
3. **续签策略**：决定何时以及如何续签令牌
4. **安全措施**：防止XSS、CSRF等攻击，保护JWT的安全

我们的商城小程序项目中，通过正确配置JWT参数和创建合适的中间件，成功实现了基于角色的权限控制和无状态的用户认证系统。

## 注意事项与最佳实践

1. **环境变量管理**
   - 所有环境变量都应在各环境配置文件中明确设置
   - 关键安全参数（如JWT密钥）在生产环境应使用强随机值
   - 使用环境变量前应进行存在性检查或提供默认值

2. **前后端分离架构**
   - 前端和后端应分别在不同端口运行，通过代理解决跨域问题
   - API路径设计应保持一致性，避免混淆

3. **安全实践**
   - JWT密钥应为复杂随机字符串，且在不同环境中使用不同值
   - 生产环境密码应遵循强密码规则
   - 敏感配置不应提交到代码仓库，建议使用.env.local或专门的密钥管理服务 